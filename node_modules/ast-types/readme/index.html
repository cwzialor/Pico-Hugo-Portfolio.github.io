<!DOCTYPE html>
<html lang="en-GB">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title> | My New Hugo Site</title>

	<link rel="stylesheet" href="css/pico.min.css" type="text/css" media="all" />
	<link rel="stylesheet" href="css/style.css" type="text/css" media="all" />
	<link rel="stylesheet" href="../css/pico.min.css" type="text/css" media="all" />
	<link rel="stylesheet" href="../css/style.css" type="text/css" media="all" />
	<link rel="stylesheet" href="../../css/pico.min.css" type="text/css" media="all" />
	<link rel="stylesheet" href="../../css/style.css" type="text/css" media="all" />

	</head>

<body>
	<nav>
		<ul>
		  <li>
			<a href="http://localhost:1313/">
				<strong>
					My New Hugo Site
				</strong>
			</a>
		</li>
		</ul>
		<ul>
		  <a href="#"> 
			<header class="site-header">
  <nav class="site-nav">
    <ul class="main-menu">
  
        
      <li>
        <a href="/posts"> Posts </a>
      </li>
      
      <li>
        <a href="/about"> About </a>
      </li>
      
      <li>
        <a href="mailto:caspar.zialor@sjtu.edu.cn">Email</a>
      </li>
    </ul>
  </nav>
</header>
 
		  </a>
		</ul>
	  </nav>

<main class="content">

<main>
    <h1></h1>
    <h1 id="ast-types-cihttpsgithubcombenjamnast-typesworkflowscibadgesvg">AST Types <img src="https://github.com/benjamn/ast-types/workflows/CI/badge.svg" alt="CI"></h1>
<p>This module provides an efficient, modular,
<a href="https://github.com/ariya/esprima">Esprima</a>-compatible implementation of
the <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax
tree</a> type hierarchy
pioneered by the <a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API">Mozilla Parser
API</a>.</p>
<h2 id="installation">Installation</h2>
<p>From NPM:</p>
<pre><code>npm install ast-types
</code></pre>
<p>From GitHub:</p>
<pre><code>cd path/to/node_modules
git clone git://github.com/benjamn/ast-types.git
cd ast-types
npm install .
</code></pre>
<h2 id="basic-usage">Basic Usage</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">assert</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;assert&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">namedTypes</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">n</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">builders</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">b</span>,
</span></span><span style="display:flex;"><span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;ast-types&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">fooId</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">identifier</span>(<span style="color:#e6db74">&#34;foo&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ifFoo</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ifStatement</span>(<span style="color:#a6e22e">fooId</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">blockStatement</span>([
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">expressionStatement</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">callExpression</span>(<span style="color:#a6e22e">fooId</span>, []))
</span></span><span style="display:flex;"><span>]));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">ok</span>(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">IfStatement</span>.<span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">ifFoo</span>));
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">ok</span>(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Statement</span>.<span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">ifFoo</span>));
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">ok</span>(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Node</span>.<span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">ifFoo</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">ok</span>(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">BlockStatement</span>.<span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">ifFoo</span>.<span style="color:#a6e22e">consequent</span>));
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">strictEqual</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ifFoo</span>.<span style="color:#a6e22e">consequent</span>.<span style="color:#a6e22e">body</span>[<span style="color:#ae81ff">0</span>].<span style="color:#a6e22e">expression</span>.<span style="color:#a6e22e">arguments</span>.<span style="color:#a6e22e">length</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">strictEqual</span>(<span style="color:#a6e22e">ifFoo</span>.<span style="color:#a6e22e">test</span>, <span style="color:#a6e22e">fooId</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">ok</span>(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Expression</span>.<span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">ifFoo</span>.<span style="color:#a6e22e">test</span>));
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">ok</span>(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Identifier</span>.<span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">ifFoo</span>.<span style="color:#a6e22e">test</span>));
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">ok</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Statement</span>.<span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">ifFoo</span>.<span style="color:#a6e22e">test</span>));
</span></span></code></pre></div><h2 id="ast-traversal">AST Traversal</h2>
<p>Because it understands the AST type system so thoroughly, this library
is able to provide excellent node iteration and traversal mechanisms.</p>
<p>If you want complete control over the traversal, and all you need is a way
of enumerating the known fields of your AST nodes and getting their
values, you may be interested in the primitives <code>getFieldNames</code> and
<code>getFieldValue</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">getFieldNames</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">getFieldValue</span>,
</span></span><span style="display:flex;"><span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;ast-types&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">partialFunExpr</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;FunctionExpression&#34;</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Even though partialFunExpr doesn&#39;t actually contain all the fields that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// are expected for a FunctionExpression, types.getFieldNames knows:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getFieldNames</span>(<span style="color:#a6e22e">partialFunExpr</span>));
</span></span><span style="display:flex;"><span><span style="color:#75715e">// [ &#39;type&#39;, &#39;id&#39;, &#39;params&#39;, &#39;body&#39;, &#39;generator&#39;, &#39;expression&#39;,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   &#39;defaults&#39;, &#39;rest&#39;, &#39;async&#39; ]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// For fields that have default values, types.getFieldValue will return
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// the default if the field is not actually defined.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">getFieldValue</span>(<span style="color:#a6e22e">partialFunExpr</span>, <span style="color:#e6db74">&#34;generator&#34;</span>));
</span></span><span style="display:flex;"><span><span style="color:#75715e">// false
</span></span></span></code></pre></div><p>Two more low-level helper functions, <code>eachField</code> and <code>someField</code>, are
defined in terms of <code>getFieldNames</code> and <code>getFieldValue</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// Iterate over all defined fields of an object, including those missing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// or undefined, passing each field name and effective value (as returned
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// by getFieldValue) to the callback. If the object has no corresponding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Def, the callback will never be called.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">eachField</span>(<span style="color:#a6e22e">object</span>, <span style="color:#a6e22e">callback</span>, <span style="color:#a6e22e">context</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">getFieldNames</span>(<span style="color:#a6e22e">object</span>).<span style="color:#a6e22e">forEach</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">name</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">callback</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">this</span>, <span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">getFieldValue</span>(<span style="color:#a6e22e">object</span>, <span style="color:#a6e22e">name</span>));
</span></span><span style="display:flex;"><span>  }, <span style="color:#a6e22e">context</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Similar to eachField, except that iteration stops as soon as the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// callback returns a truthy value. Like Array.prototype.some, the final
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// result is either true or false to indicates whether the callback
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// returned true for any element or not.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">someField</span>(<span style="color:#a6e22e">object</span>, <span style="color:#a6e22e">callback</span>, <span style="color:#a6e22e">context</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">getFieldNames</span>(<span style="color:#a6e22e">object</span>).<span style="color:#a6e22e">some</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">name</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">callback</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">this</span>, <span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">getFieldValue</span>(<span style="color:#a6e22e">object</span>, <span style="color:#a6e22e">name</span>));
</span></span><span style="display:flex;"><span>  }, <span style="color:#a6e22e">context</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So here&rsquo;s how you might make a copy of an AST node:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">eachField</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;ast-types&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">copy</span> <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">eachField</span>(<span style="color:#a6e22e">node</span>, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">value</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Note that undefined fields will be visited too, according to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// the rules associated with node.type, and default field values
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// will be substituted if appropriate.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">copy</span>[<span style="color:#a6e22e">name</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>But that&rsquo;s not all! You can also easily visit entire syntax trees using
the powerful <code>types.visit</code> abstraction.</p>
<p>Here&rsquo;s a trivial example of how you might assert that <code>arguments.callee</code>
is never used in <code>ast</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">assert</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;assert&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">import</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">visit</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">namedTypes</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">n</span>,
</span></span><span style="display:flex;"><span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;ast-types&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">visit</span>(<span style="color:#a6e22e">ast</span>, {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// This method will be called for any node with .type &#34;MemberExpression&#34;:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">visitMemberExpression</span>(<span style="color:#a6e22e">path</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Visitor methods receive a single argument, a NodePath object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// wrapping the node of interest.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">node</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Identifier</span>.<span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">object</span>) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">object</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;arguments&#34;</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Identifier</span>.<span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">property</span>)
</span></span><span style="display:flex;"><span>    ) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">notStrictEqual</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">property</span>.<span style="color:#a6e22e">name</span>, <span style="color:#e6db74">&#34;callee&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// It&#39;s your responsibility to call this.traverse with some
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// NodePath object (usually the one passed into the visitor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// method) before the visitor method returns, or return false to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// indicate that the traversal need not continue any further down
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// this subtree.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">path</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>Here&rsquo;s a slightly more involved example of transforming <code>...rest</code>
parameters into browser-runnable ES5 JavaScript:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">builders</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">visit</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;ast-types&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Reuse the same AST structure for Array.prototype.slice.call.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sliceExpr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">memberExpression</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">memberExpression</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">memberExpression</span>(
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">identifier</span>(<span style="color:#e6db74">&#34;Array&#34;</span>),
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">identifier</span>(<span style="color:#e6db74">&#34;prototype&#34;</span>),
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    ),
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">identifier</span>(<span style="color:#e6db74">&#34;slice&#34;</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>  ),
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">identifier</span>(<span style="color:#e6db74">&#34;call&#34;</span>),
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">visit</span>(<span style="color:#a6e22e">ast</span>, {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// This method will be called for any node whose type is a subtype of
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Function (e.g., FunctionDeclaration, FunctionExpression, and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// ArrowFunctionExpression). Note that types.visit precomputes a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// lookup table from every known type to the appropriate visitor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// method to call for nodes of that type, so the dispatch takes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// constant time.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">visitFunction</span>(<span style="color:#a6e22e">path</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Visitor methods receive a single argument, a NodePath object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// wrapping the node of interest.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">node</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// It&#39;s your responsibility to call this.traverse with some
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// NodePath object (usually the one passed into the visitor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// method) before the visitor method returns, or return false to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// indicate that the traversal need not continue any further down
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// this subtree. An assertion will fail if you forget, which is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// awesome, because it means you will never again make the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// disastrous mistake of forgetting to traverse a subtree. Also
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// cool: because you can call this method at any point in the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// visitor method, it&#39;s up to you whether your traversal is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// pre-order, post-order, or both!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">path</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// This traversal is only concerned with Function nodes that have
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// rest parameters.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">rest</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// For the purposes of this example, we won&#39;t worry about functions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// with Expression bodies.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">BlockStatement</span>.<span style="color:#a6e22e">assert</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">body</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Use types.builders to build a variable declaration of the form
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//   var rest = Array.prototype.slice.call(arguments, n);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// where `rest` is the name of the rest parameter, and `n` is a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// numeric literal specifying the number of named parameters the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// function takes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">restVarDecl</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">variableDeclaration</span>(<span style="color:#e6db74">&#34;var&#34;</span>, [
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">variableDeclarator</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">rest</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">callExpression</span>(<span style="color:#a6e22e">sliceExpr</span>, [
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">identifier</span>(<span style="color:#e6db74">&#34;arguments&#34;</span>),
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">literal</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">params</span>.<span style="color:#a6e22e">length</span>)
</span></span><span style="display:flex;"><span>        ])
</span></span><span style="display:flex;"><span>      )
</span></span><span style="display:flex;"><span>    ]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Similar to doing node.body.body.unshift(restVarDecl), except
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// that the other NodePath objects wrapping body statements will
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// have their indexes updated to accommodate the new statement.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;body&#34;</span>, <span style="color:#e6db74">&#34;body&#34;</span>).<span style="color:#a6e22e">unshift</span>(<span style="color:#a6e22e">restVarDecl</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Nullify node.rest now that we have simulated the behavior of
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// the rest parameter using ordinary JavaScript.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;rest&#34;</span>).<span style="color:#a6e22e">replace</span>(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// There&#39;s nothing wrong with doing node.rest = null, but I wanted
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// to point out that the above statement has the same effect.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">strictEqual</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">rest</span>, <span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>Here&rsquo;s how you might use <code>types.visit</code> to implement a function that
determines if a given function node refers to <code>this</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">usesThis</span>(<span style="color:#a6e22e">funcNode</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">n</span>.Function.<span style="color:#a6e22e">assert</span>(<span style="color:#a6e22e">funcNode</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">visit</span>(<span style="color:#a6e22e">funcNode</span>, {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">visitThisExpression</span>(<span style="color:#a6e22e">path</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// The quickest way to terminate the traversal is to call
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// this.abort(), which throws a special exception (instanceof
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// this.AbortRequest) that will be caught in the top-level
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// types.visit method, so you don&#39;t have to worry about
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// catching the exception yourself.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">abort</span>();
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">visitFunction</span>(<span style="color:#a6e22e">path</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// ThisExpression nodes in nested scopes don&#39;t count as `this`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// references for the original function node, so we can safely
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// avoid traversing this subtree.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">visitCallExpression</span>(<span style="color:#a6e22e">path</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">node</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// If the function contains CallExpression nodes involving
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// super, those expressions will implicitly depend on the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// value of `this`, even though they do not explicitly contain
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// any ThisExpression nodes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isSuperCallExpression</span>(<span style="color:#a6e22e">node</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">abort</span>(); <span style="color:#75715e">// Throws AbortRequest exception.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">path</span>);
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Yes, you can define arbitrary helper methods.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">isSuperCallExpression</span>(<span style="color:#a6e22e">callExpr</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">CallExpression</span>.<span style="color:#a6e22e">assert</span>(<span style="color:#a6e22e">callExpr</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isSuperIdentifier</span>(<span style="color:#a6e22e">callExpr</span>.<span style="color:#a6e22e">callee</span>)
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">||</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">isSuperMemberExpression</span>(<span style="color:#a6e22e">callExpr</span>.<span style="color:#a6e22e">callee</span>);
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// And even helper helper methods!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">isSuperIdentifier</span>(<span style="color:#a6e22e">node</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Identifier</span>.<span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">callee</span>)
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">callee</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;super&#34;</span>;
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">isSuperMemberExpression</span>(<span style="color:#a6e22e">node</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">MemberExpression</span>.<span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">callee</span>)
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Identifier</span>.<span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">callee</span>.<span style="color:#a6e22e">object</span>)
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">callee</span>.<span style="color:#a6e22e">object</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;super&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you might guess, when an <code>AbortRequest</code> is thrown from a subtree, the
exception will propagate from the corresponding calls to <code>this.traverse</code>
in the ancestor visitor methods. If you decide you want to cancel the
request, simply catch the exception and call its <code>.cancel()</code> method. The
rest of the subtree beneath the <code>try</code>-<code>catch</code> block will be abandoned, but
the remaining siblings of the ancestor node will still be visited.</p>
<h2 id="nodepath">NodePath</h2>
<p>The <code>NodePath</code> object passed to visitor methods is a wrapper around an AST
node, and it serves to provide access to the chain of ancestor objects
(all the way back to the root of the AST) and scope information.</p>
<p>In general, <code>path.node</code> refers to the wrapped node, <code>path.parent.node</code>
refers to the nearest <code>Node</code> ancestor, <code>path.parent.parent.node</code> to the
grandparent, and so on.</p>
<p>Note that <code>path.node</code> may not be a direct property value of
<code>path.parent.node</code>; for instance, it might be the case that <code>path.node</code> is
an element of an array that is a direct child of the parent node:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">node</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">parent</span>.<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">elements</span>[<span style="color:#ae81ff">3</span>]
</span></span></code></pre></div><p>in which case you should know that <code>path.parentPath</code> provides
finer-grained access to the complete path of objects (not just the <code>Node</code>
ones) from the root of the AST:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// In reality, path.parent is the grandparent of path:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">parentPath</span>.<span style="color:#a6e22e">parentPath</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">parent</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The path.parentPath object wraps the elements array (note that we use
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// .value because the elements array is not a Node):
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">parentPath</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">parent</span>.<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">elements</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The path.node object is the fourth element in that array:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">parentPath</span>.<span style="color:#a6e22e">value</span>[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">===</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Unlike path.node and path.value, which are synonyms because path.node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// is a Node object, path.parentPath.node is distinct from
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// path.parentPath.value, because the elements array is not a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Node. Instead, path.parentPath.node refers to the closest ancestor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Node, which happens to be the same as path.parent.node:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">parentPath</span>.<span style="color:#a6e22e">node</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">parent</span>.<span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The path is named for its index in the elements array:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Likewise, path.parentPath is named for the property by which
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// path.parent.node refers to it:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">parentPath</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;elements&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Putting it all together, we can follow the chain of object references
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// from path.parent.node all the way to path.node by accessing each
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// property by name:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">parent</span>.<span style="color:#a6e22e">node</span>[<span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">parentPath</span>.<span style="color:#a6e22e">name</span>][<span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">name</span>] <span style="color:#f92672">===</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">node</span>
</span></span></code></pre></div><p>These <code>NodePath</code> objects are created during the traversal without
modifying the AST nodes themselves, so it&rsquo;s not a problem if the same node
appears more than once in the AST (like <code>Array.prototype.slice.call</code> in
the example above), because it will be visited with a distict <code>NodePath</code>
each time it appears.</p>
<p>Child <code>NodePath</code> objects are created lazily, by calling the <code>.get</code> method
of a parent <code>NodePath</code> object:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// If a NodePath object for the elements array has never been created
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// before, it will be created here and cached in the future:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;elements&#34;</span>).<span style="color:#a6e22e">get</span>(<span style="color:#ae81ff">3</span>).<span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">elements</span>[<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Alternatively, you can pass multiple property names to .get instead of
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// chaining multiple .get calls:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;elements&#34;</span>, <span style="color:#ae81ff">0</span>).<span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">elements</span>[<span style="color:#ae81ff">0</span>]
</span></span></code></pre></div><p><code>NodePath</code> objects support a number of useful methods:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// Replace one node with another node:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">fifth</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;elements&#34;</span>, <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fifth</span>.<span style="color:#a6e22e">replace</span>(<span style="color:#a6e22e">newNode</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Now do some stuff that might rearrange the list, and this replacement
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// remains safe:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fifth</span>.<span style="color:#a6e22e">replace</span>(<span style="color:#a6e22e">newerNode</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Replace the third element in an array with two new nodes:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;elements&#34;</span>, <span style="color:#ae81ff">2</span>).<span style="color:#a6e22e">replace</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">identifier</span>(<span style="color:#e6db74">&#34;foo&#34;</span>),
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">thisExpression</span>()
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Remove a node and its parent if it would leave a redundant AST node:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//e.g. var t = 1, y =2; removing the `t` and `y` declarators results in `var undefined`.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">prune</span>(); <span style="color:#75715e">//returns the closest parent `NodePath`.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Remove a node from a list of nodes:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;elements&#34;</span>, <span style="color:#ae81ff">3</span>).<span style="color:#a6e22e">replace</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Add three new nodes to the beginning of a list of nodes:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;elements&#34;</span>).<span style="color:#a6e22e">unshift</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Remove and return the first node in a list of nodes:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;elements&#34;</span>).<span style="color:#a6e22e">shift</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Push two new nodes onto the end of a list of nodes:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;elements&#34;</span>).<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">d</span>, <span style="color:#a6e22e">e</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Remove and return the last node in a list of nodes:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;elements&#34;</span>).<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Insert a new node before/after the seventh node in a list of nodes:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">seventh</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;elements&#34;</span>, <span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">seventh</span>.<span style="color:#a6e22e">insertBefore</span>(<span style="color:#a6e22e">newNode</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">seventh</span>.<span style="color:#a6e22e">insertAfter</span>(<span style="color:#a6e22e">newNode</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Insert a new element at index 5 in a list of nodes:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">path</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#34;elements&#34;</span>).<span style="color:#a6e22e">insertAt</span>(<span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">newNode</span>);
</span></span></code></pre></div><h2 id="scope">Scope</h2>
<p>The object exposed as <code>path.scope</code> during AST traversals provides
information about variable and function declarations in the scope that
contains <code>path.node</code>. See <a href="lib/scope.ts">scope.ts</a> for its public
interface, which currently includes <code>.isGlobal</code>, <code>.getGlobalScope()</code>,
<code>.depth</code>, <code>.declares(name)</code>, <code>.lookup(name)</code>, and <code>.getBindings()</code>.</p>
<h2 id="custom-ast-node-types">Custom AST Node Types</h2>
<p>The <code>ast-types</code> module was designed to be extended. To that end, it
provides a readable, declarative syntax for specifying new AST node types,
based primarily upon the <code>require(&quot;ast-types&quot;).Type.def</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Type</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">builtInTypes</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">builders</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">b</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">finalize</span>,
</span></span><span style="display:flex;"><span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;ast-types&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">def</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">Type</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">string</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">builtInTypes</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Suppose you need a named File type to wrap your Programs.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">def</span>(<span style="color:#e6db74">&#34;File&#34;</span>)
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">bases</span>(<span style="color:#e6db74">&#34;Node&#34;</span>)
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">build</span>(<span style="color:#e6db74">&#34;name&#34;</span>, <span style="color:#e6db74">&#34;program&#34;</span>)
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">field</span>(<span style="color:#e6db74">&#34;name&#34;</span>, <span style="color:#a6e22e">string</span>)
</span></span><span style="display:flex;"><span>  .<span style="color:#a6e22e">field</span>(<span style="color:#e6db74">&#34;program&#34;</span>, <span style="color:#a6e22e">def</span>(<span style="color:#e6db74">&#34;Program&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Prevent further modifications to the File type (and any other
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// types newly introduced by def(...)).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">finalize</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// The b.file builder function is now available. It expects two
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// arguments, as named by .build(&#34;name&#34;, &#34;program&#34;) above.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">file</span>(<span style="color:#e6db74">&#34;main.js&#34;</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">program</span>([
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Pointless program contents included for extra color.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">functionDeclaration</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">identifier</span>(<span style="color:#e6db74">&#34;succ&#34;</span>), [
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">identifier</span>(<span style="color:#e6db74">&#34;x&#34;</span>)
</span></span><span style="display:flex;"><span>  ], <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">blockStatement</span>([
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">returnStatement</span>(
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">binaryExpression</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;+&#34;</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">identifier</span>(<span style="color:#e6db74">&#34;x&#34;</span>), <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">literal</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>      )
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>  ]))
</span></span><span style="display:flex;"><span>]));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">strictEqual</span>(<span style="color:#a6e22e">main</span>.<span style="color:#a6e22e">name</span>, <span style="color:#e6db74">&#34;main.js&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">assert</span>.<span style="color:#a6e22e">strictEqual</span>(<span style="color:#a6e22e">main</span>.<span style="color:#a6e22e">program</span>.<span style="color:#a6e22e">body</span>[<span style="color:#ae81ff">0</span>].<span style="color:#a6e22e">params</span>[<span style="color:#ae81ff">0</span>].<span style="color:#a6e22e">name</span>, <span style="color:#e6db74">&#34;x&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// etc.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// If you pass the wrong type of arguments, or fail to pass enough
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// arguments, an AssertionError will be thrown.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">file</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">blockStatement</span>([]));
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ==&gt; AssertionError: {&#34;body&#34;:[],&#34;type&#34;:&#34;BlockStatement&#34;,&#34;loc&#34;:null} does not match type string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">file</span>(<span style="color:#e6db74">&#34;lib/types.js&#34;</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">thisExpression</span>());
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ==&gt; AssertionError: {&#34;type&#34;:&#34;ThisExpression&#34;,&#34;loc&#34;:null} does not match type Program
</span></span></span></code></pre></div><p>The <code>def</code> syntax is used to define all the default AST node types found in
<a href="def/babel-core.ts">babel-core.ts</a>,
<a href="def/babel.ts">babel.ts</a>,
<a href="def/core.ts">core.ts</a>,
<a href="def/es-proposals.ts">es-proposals.ts</a>,
<a href="def/es6.ts">es6.ts</a>,
<a href="def/es7.ts">es7.ts</a>,
<a href="def/es2020.ts">es2020.ts</a>,
<a href="def/esprima.ts">esprima.ts</a>,
<a href="def/flow.ts">flow.ts</a>,
<a href="def/jsx.ts">jsx.ts</a>,
<a href="def/type-annotations.ts">type-annotations.ts</a>,
and
<a href="def/typescripts.ts">typescripts.ts</a>,
so you have
no shortage of examples to learn from.</p>

</main>

</main>
	
<footer>
	<p>&copy;2024 My New Hugo Site</p>
</footer>

</body>
</html>

